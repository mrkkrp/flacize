#!/usr/bin/env python
#
# Convert any audio files into CDDA quality FLAC tracks.
#
# Copyright © 2015 Mark Karpov <markkarpov@openmailbox.org>
#
# flacize is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# flacize is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <http://www.gnu.org/licenses/>.

import argparse, os, subprocess, sys

# Constants and other useful values

prog_name = os.path.basename(__file__)
version = '0.1.0'
description = 'Convert any audio files into CDDA quality FLAC tracks'
license = """flacize — Convert any audio files into CDDA quality FLAC tracks

Copyright © 2015 Mark Karpov

flacize is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

flacize is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.
"""

approved_tags = frozenset(
    { 'ALBUM'
    , 'ARTIST'
    , 'DATE'
    , 'TITLE'
    , 'TRACKNUMBER'
    , 'TRACKTOTAL'})

parser = argparse.ArgumentParser(description=description)
parser.add_argument('dir', metavar='DIR', nargs='?', default=os.getcwd(),
                    help='directory to scan')
parser.add_argument('-o', '--output', metavar='DIR', dest='out_dir', default='',
                    help='output directory (created if needed)')
parser.add_argument('-r', '--rate', metavar='N', dest='rate', default=44100,
                    help='output sample rate (defaults to 44100 Hz)')
parser.add_argument('-w', '--width', metavar='N', dest='width', default=16,
                    help='output sample width (defaults to 16 bit)')
parser.add_argument('-c', '--channels', metavar='N', dest='chs', default=2,
                    help='number of channels (defaults to 2)')
parser.add_argument('-p', '--preserve', action='store_true', dest='preserve',
                    help='preserve quality of originals')
parser.add_argument('-d', '--delete', action='store_true', dest='delete',
                    help='delete original files after conversion')
parser.add_argument('-s', '--shift', metavar='N', dest='shift', default=0,
                    help='add N to index of every track')
parser.add_argument('-t', '--total', metavar='N', dest='total',
                    help='specify total number of tracks N')
parser.add_argument('-e', '--crop', metavar='N', dest='crop', default=0,
                    help='crop last N tracks (e.g. remove bonus tracks)')
parser.add_argument('--license', action='store_true', dest='show_license',
                    help="show program's license and exit")
parser.add_argument('--version', action='version',
                    version='%(prog)s ' + version)

args = parser.parse_args()

# Some functions that help us to fulfill our task.

def failure(str):
    """
    Print error message ‘str’ to stderr and exit with code 1.
    """
    print(prog_name, ": error: ", str, file=sys.stderr)
    exit(1)

def get_track_descs():
    """
    Return list of dictionaries containing full description of every track
    to process. The returned information is already corrected according to
    used command line options. Directory to scan is ‘arg.dir’, dispatch for
    .cue + audio data is automatic.
    """
    ...

def get_cue_track_descs(cue_file, audio_file):
    """
    Return list of dictionaries containing full description of every track to
    process. This function tries to process .cue + audio thing.
    """
    ...

def get_dis_track_descs(files):
    """
    Return list of dictionaries containing full description of every track
    to process. This function works with collection of separate tracks.
    """
    ...

def convert_file(**params):
    """
    Convert audio file using FFmpeg converter. ‘params’ dictionary must
    contain “original” and “result” entries, other parameters are optional
    (if they are absent, presume parameters of original):

    “start_time” — result file must be fragment of original file starting at
    this moment of time (floating point value, number of seconds or string
    of NN:NN:NN.XXX format).

    “end_time” — result file must be fragment of original file and this is
    when it must end (floating point value, number of seconds or string of
    NN:NN:NN.XXX format).

    “sample_rate” — sample rate of result file, in hertz.

    “sample_width” — sample width of result file, in bits, valid values are
    8, 16, and 32.

    “channels” — number of channels in result file.

    Return name of result file.
    """
    cmd = ['ffmpeg', '-y']
    def add_to_cmd(value, option):
        nonlocal cmd
        if value:
            cmd.extend([option, str(value)])
    add_to_cmd(params['start_time'], '-ss')
    add_to_cmd(params['end_time'], '-to')
    add_to_cmd(params['sample_rate'], '-ar')
    add_to_cmd({8: 'u8', 16: 's16', 32: 's32'}.get(params.get('sample_width')),
               '-sample-fmt')
    add_to_cmd(params[''])
    add_to_cmd(params['channels'], '-ac')
    cmd.extend(['-i', params['original']])
    cmd.append(params['result'])
    print(cmd) # subprocess.call(cmd)
    params['result']

def write_tags(filename, **tags):
    """
    Write approved tags from ‘tags’ dictionary into filename
    ‘filename’. Approved tags are listed in ‘approved_tags’.
    """
    # f = taglib.File(filename)
    # f.tags = {k: [tags[k]] for k in approved_tags}
    # f.save()
    print('tags ', {k: [tags[k]] for k in approved_tags})

# Execution starts here, show license if user wants to see it.

if args.show_license:
    print(license)
    exit(0)

# Test if FFmpeg console application is present on this system, just in
# case.

if not shutil.which('ffmpeg'):
    failure('cannot find ‘ffmpeg’ program')

# If user has specified output directory, we should make sure that it does
# exist.

if args.out_dir: os.makedirs(args.out_dir, exist_ok=True)

# First of all, we need to get list of dictionaries that contain meta-data,
# file name, information about start time and end time, indexation and total
# number of tracks, etc. The whole list must be formed before translation
# because need to have all the data at once (for example to count total
# number of tracks or specify start and end time for audio that comes with a
# .cue file). Every dictionary in the list may duplicate some info, the idea
# is that it must contain full description of given track for processing.

track_descs = get_track_descs()

for desc in track_descs:
    write_tags(convert_file(**desc), **desc)

if arg.delete:
    for original in {desc['original'] for desc in track_descs}:
        print('deleting ', original) # os.remove(original)

# List of features:

# - Output format: FLAC tracks, always use maximal compression.

# - User should be able to specify output quality.

# - Default quality should be CDDA: 44.1 kHz, 16 bit, 2 channels.

# - An option to preserve quality.

# - Process files in current directory or in specified directory.

# - An option to specify output directory (created if needed).

# - An option to delete original files automatically.

# - An option to increment index of every composition.

# - An option to specify total number of compositions (overwrite inferred).

# - An option to eliminate N last tracks (correct total number of tracks
#   unless it's specified explicitly).

# - If there is a .cue file in actual directory, find corresponding audio
#   file and split it as needed, produce separate tracks.

# - If there are several .cue files in actual directory, abort execution and
#   tell user that he needs to store stuff separately.

# - For CUEd files .cue files is the source of tags.

# - Preserve useful tags: «artist», «album», «year», «title», but process
#   them so they are in normal form (delete extra white-space, etc).

# - If tag «track index» present, use it to calculate index of composition
#   (but correct it too, delete leading zeros, for example). If such a tag
#   is missing and we deal with separate tracks, use index of actual
#   composition in list of sorted file names to get its index.

# - Tag «total tracks» is either given explicitly or it's calculated as
#   total number of files to process (see additional manipulations above).

# - Make sure that tags «comment» and «genre» are always empty, as well as
#   all other tags that we don't specify explicitly (total number of disks,
#   for example).

# - Names of result files are not the same as original (which may be absent
#   if it's .cue + single audio file scheme), but are composed by this
#   pattern ‘NN Composition Title.flac’. So tag «track index» and «title»
#   determine file name fully.
